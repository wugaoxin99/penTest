package com.qf.sort;

import java.util.Arrays;

/**
 * 有2,3,5数枚硬币，求112至少要多少枚硬币组成
 * 通过动态规划算法--->分而治之
 * 不想整体，先考虑局部
 * f(112)=f(107)+1,表示112的硬币数量由107需要的硬币数量加1枚5元硬币
 * f(112)=f(109)+1,表示112的硬币数量由109需要的硬币数量加1枚3元硬币
 * f(112)=f(110)+1,表示112的硬币数量由110需要的硬币数量加1枚2元硬币
 * 求这三个的最小硬币数量，即f(112)=min{f(112)=f(107)+1, f(112)=f(109)+1, f(112)=f(110)+1}
 * 以此类推
 * ...
 * f(5)=1
 * f(4)=2
 * f(3)=1
 * f(2)=1
 * f(1)=-1  凑不齐该金额
 * f(0)=0
 * 定义状态关系：f(i)=j  表示当要组成i元时需要j枚硬币
 * 状态转移方程：f(i)=min{f(i-5)+1, f(i-3)+1, f(i-2)+1}
 */
public class Main1 {
    public static void main(String[] args) {
        //拥有的硬币面额
        int[] money={2, 3, 5};

        //需凑成的金额
        int maxMoney=23;

        //数组f的下标(0~112)表示要凑齐的钱数，f的值表示需要的硬币数量
        int[] f=new int[maxMoney+1];

        for (int i = 0; i < f.length; i++) {
            if (i==0){
                //凑齐0元所需的硬币数量
                f[i]=0;
            }else if (i<money[0]){
                //凑不齐该金额，如1元凑不齐
                f[i]=-1;
            }else if (i==2||i==3||i==5){
                //2,3,5只需要一枚硬币
                f[i]=1;
            }else {
                //声明一个number为最大值
                int number=Integer.MAX_VALUE;
                if (i>5&&f[i-5]!=-1){
                    //如果金额大于5并且减5后的金额能被凑齐，即不是1元这种凑不齐的金额
                    number=Math.min(f[i-5]+1,number);
                }
                if (i>3&&f[i-3]!=-1){
                    number=Math.min(f[i-3]+1,number);
                }
                if (i>2&&f[i-2]!=-1){
                    number=Math.min(f[i-2]+1,number);
                }
                if (number==Integer.MAX_VALUE){
                    number=-1;
                }
                f[i]=number;//f(i)=j
            }
        }
        System.out.println("凑成金额为"+maxMoney+"元需要的硬币数量--->"+f[maxMoney]);
        System.out.println("0~"+maxMoney+"元需要的硬币数量--->"+ Arrays.toString(f));
    }
}
