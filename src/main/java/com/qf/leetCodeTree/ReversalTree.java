package com.qf.leetCodeTree;

/**
 * 二叉树翻转
 */
public class ReversalTree {
    public static void main(String[] args) {
        BinaryTreeImplement binaryTreeImplement=new BinaryTreeImplement();
        BinaryTreeNode root = binaryTreeImplement.createBinaryTree();
        System.out.println("使用先序遍历原二叉树：");
        binaryTreeImplement.preOrder(root);
        reverSalTrees(root);
        System.out.println("\n使用先序遍历翻转后的二叉树：");
        binaryTreeImplement.preOrder(root);
    }
    private static void reverSalTrees(BinaryTreeNode root){
        if (root==null){
            return;
        }
        BinaryTreeNode leftTreeNode = root.getLeftTreeNode();
        BinaryTreeNode rightTreeNode = root.getRightTreeNode();
        if (null!=leftTreeNode){
            root.setRightTreeNode(leftTreeNode);
        }
        if (null!=rightTreeNode){
            root.setLeftTreeNode(rightTreeNode);
        }
        /**
         * 如果叶子数一边为空另一边不为空，则要将不为空一边置空
         * 这样子是为了防止翻转之后出现两边都有值，且两个值相同
         */
        if (null==leftTreeNode&&null!=rightTreeNode){
            root.setRightTreeNode(null);
        }else if (null!=leftTreeNode&&null==rightTreeNode){
            root.setLeftTreeNode(null);
        }
        reverSalTrees(leftTreeNode);
        reverSalTrees(rightTreeNode);
    }
    //力扣官方给出的递归实现翻转二叉树
    public static BinaryTreeNode invertTree(BinaryTreeNode root) {
        if (root == null) {
            return null;
        }
        BinaryTreeNode right = invertTree(root.getRightTreeNode());
        BinaryTreeNode left = invertTree(root.getLeftTreeNode());
        root.setLeftTreeNode(right);
        root.setRightTreeNode(left);
        return root;
    }
}
